<script>
  import { onMount, onDestroy, createEventDispatcher } from 'svelte'
  import { createRichTextEditor } from './state'
  import { EditorView } from 'prosemirror-view'

  const dispatch = createEventDispatcher()
  export let body = ''
  export let editorState = createRichTextEditor(body)
  export let placeholder = ''
  export let view = null
  /** Debounce change events (set to zero for immediate updates) */
  export let debounceChangeEventsInterval = 50
  export let editor = null
  export let editorViewProps = {}
  export const focus = () => view && view.focus()
  export const blur = () => editor && editor.blur()
  let dispatchLastEditTimeout
  let isDirty = false

  $: if (view && editorState && !isDirty) {
    view.updateState(editorState) // necessary to keep the DOM in sync with the editor state on external updates
  }

  /** Tracks whether the editor is empty (i.e. has a content size of 0) */
  let editorIsEmpty
  $: editorIsEmpty = editorState
    ? editorState.doc.content.size === 0 ||
      (editorState.doc.textContent === '' && editorState.doc.content.size < 3)
    : true

  /** Dispatches a change event and resets whether the editor state is dirty */
  const dispatchChangeEvent = () => {
    if (isDirty) {
      dispatch('change', { editorState })
      isDirty = false
    }
  }

  /**
   * Captures custom events from plugins and dispatches them with a new event type (based on event.detail.type)
   * @param event {CustomEvent}
   */
  const onCustomEvent = (event) => {
    if (event.detail) {
      const { type, ...detail } = event.detail
      dispatch(type || 'custom', detail)
    }
  }

  onMount(() => {
    editor.focus()
    view = new EditorView(
      { mount: editor },
      {
        ...editorViewProps,
        state: editorState,
        dispatchTransaction: (transaction) => {
          editorState = view.state.apply(transaction)

          const contentHasChanged = !editorState.doc.eq(view.state.doc)

          if (contentHasChanged) {
            isDirty = true
            if (debounceChangeEventsInterval > 0) {
              if (dispatchLastEditTimeout) clearTimeout(dispatchLastEditTimeout)
              dispatchLastEditTimeout = setTimeout(dispatchChangeEvent, 50)
            } else {
              setTimeout(dispatchChangeEvent, 0)
            }
          }

          view.updateState(editorState)

          dispatch('transaction', {
            view,
            editorState,
            isDirty,
            contentHasChanged,
          })
        },
      }
    )
  })

  onDestroy(() => {
    view.destroy()
  })
</script>

<div
  class:ProseMirror={true}
  class:editor_empty={editorIsEmpty}
  data-placeholder={placeholder}
  bind:this={editor}
  on:focus
  on:blur
  on:keydown
  on:custom={onCustomEvent}
>
  {body}
</div>

<style global>
  .ProseMirror {
    position: relative;
    word-wrap: break-word;
    white-space: pre-wrap;
    -webkit-font-variant-ligatures: none;
    font-variant-ligatures: none;
    outline: none;
  }

  .ProseMirror pre {
    white-space: pre-wrap;
  }

  .ProseMirror li {
    position: relative;
  }

  .ProseMirror-hideselection *::selection {
    background: transparent;
  }

  .ProseMirror-hideselection *::-moz-selection {
    background: transparent;
  }

  .ProseMirror-hideselection {
    caret-color: transparent;
  }

  .ProseMirror-selectednode {
    outline: 2px solid #8cf;
  }

  /* Make sure li selections wrap around markers */

  li.ProseMirror-selectednode {
    outline: none;
  }

  li.ProseMirror-selectednode:after {
    content: '';
    position: absolute;
    left: -32px;
    right: -2px;
    top: -2px;
    bottom: -2px;
    border: 2px solid #8cf;
    pointer-events: none;
  }

  .ProseMirror .empty-node::before {
    position: absolute;
    color: #aaa;
    cursor: text;
  }

  .ProseMirror .empty-node:hover::before {
    color: #777;
  }

  .ProseMirror.editor_empty::before {
    position: absolute;
    content: attr(data-placeholder);
    pointer-events: none;
    color: var(--ui-color-placeholder);
  }
</style>
